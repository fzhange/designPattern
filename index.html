<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        #outter {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div id="outter">
        <div id="inner"></div>
    </div>
</body>
<script>
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {void} Do not return anything, modify root in-place instead.
     */

    let tree = {
        name: "1",
        left: {
            name: "2",
            left: {
                name: "3"
            },
            right: {
                name: "4"
            }
        },
        right: {
            name: "5"
        }
    }
    var flatten = function (root) {
        console.log('root: ', root);
        let dummy = {};
        let pointer = dummy;
        function auxFunction(root) {
            if (!root) return;
            pointer.right = { name: root.name };
            console.log('pointer: ', pointer);
            pointer = pointer.right;

            auxFunction(root.left);
            auxFunction(root.right);
        }
        auxFunction(root);
        return dummy.right;
    };

    console.log('flatRight(tree): ', flatten(tree));


    let list = [
        { id: 1, name: '部门A', parentId: 0 },
        { id: 2, name: '部门B', parentId: 0 },
        { id: 3, name: '部门C', parentId: 1 },
        { id: 4, name: '部门D', parentId: 1 },
        { id: 5, name: '部门E', parentId: 2 },
        { id: 6, name: '部门F', parentId: 3 },
        { id: 7, name: '部门G', parentId: 2 },
        { id: 8, name: '部门H', parentId: 4 }
    ];

    function dealList(list) {
        return list.filter((item, idx) => {
            const children = list.filter((ele, index) => {
                return ele.parentId === item.id;
            })
            item.children = children;
            return item.parentId === 0;
        })
    }
    // dealList(list);
    console.log('dealList(list): ', dealList(list));
    // 输入: [-2,1,-3,4,-1,2,1,-5,4]
    // 输出: 6
    // 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    var maxSubArray = function (nums) {
        if (nums.length === 1) return nums[0];
        let preSums = [nums[0]];
        for (let i = 1; i < nums.length; i++) {
            let nowNum = nums[i];
            if (nowNum + preSums[i - 1] <= nowNum) {
                preSums[i] = nowNum;
            } else {
                preSums[i] = nowNum + preSums[i - 1];
            }
        }
    return Math.max(...preSums);
}
    // maxSubArray([4,-1,2,1])
    console.log('maxSubArray([4,-1,2,1]): ', maxSubArray([4, -1, 2, 1]));

    let data = [{
        val: 0,
        preIdx: null,
    }, {
        val: 5,
        preIdx: null,
    }, {
        val: 1,
        preIdx: null,
    }, {
        val: 8,
        preIdx: null,
    }, {
    val: 4,
        preIdx: 1,
    }, {
        val: 6,
        preIdx: null,
    }, {
        val: 3,
        preIdx: 2,
    }, {
        val: 2,
        preIdx: 3,
    }, {
        val: 4,
        preIdx: 5
    }]


    function countMaxVal(data) {
        let arr = [];
        for (let i = 1; i < data.length; i++) {
            let selectVal;
            let noSelectVal = data[i - 1].val
            if (!!data[i].preIdx) {
                let _preIdx = data[i].preIdx;
                selectVal = data[i].val + data[_preIdx].val;
            } else {
                selectVal = data[i].val;
            }

        if (selectVal > noSelectVal) {
            arr.push(selectVal);
        } else arr.push(noSelectVal);
    }
    return arr;
}

    console.log('countMaxVal(data): ', countMaxVal(data));


</script>

</html>
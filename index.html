<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui">
    <meta name="referrer" content="no-referrer">
    <title>播放器</title>
    <style type="text/css">
      #mse {flex:auto;}
      .test{
        height: 50vh;
      }
    </style>

  </head>
  <body>
    <div id="mse">
      已结束
    </div>
    
  <script type="text/javascript">



 /**
  * let str = "1,5,3,4,6,9,-1,7,8"; 
  * 求最长上升子序列 134678  注意序列的非连续性
  *  f(1) [1]
  *  f(5) f(1)[5]
  *  f(3) f(1)[3]
  *  f(4) f(3)[4]
  */

  // [[1],[1,5],[1,3],[1,3,4],[1,3,4,6],[1,3,4,6,9],[-1],[]]
  // [1]

// 定义 dp[i]dp[i] 为考虑前 ii 个元素，以第 ii 个数字结尾的最长上升子序列的长度，注意 \textit{nums}[i]nums[i] 必须被选取。

// 我们从小到大计算 dp[]dp[] 数组的值，在计算 dp[i]dp[i] 之前，我们已经计算出 dp[0 \ldots i-1]dp[0…i−1] 的值，则状态转移方程为：

// dp[i] = \text{max}(dp[j]) + 1, \text{其中} \, 0 \leq j < i \, \text{且} \, \textit{num}[j]<\textit{num}[i]
// dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]

// 即考虑往 dp[0 \ldots i-1]dp[0…i−1] 中最长的上升子序列后面再加一个 \textit{nums}[i]nums[i]。由于 dp[j]dp[j] 代表 \textit{nums}[0 \ldots j]nums[0…j] 中以 \textit{nums}[j]nums[j] 结尾的最长上升子序列，所以如果能从 dp[j]dp[j] 这个状态转移过来，那么 \textit{nums}[i]nums[i] 必然要大于 \textit{nums}[j]nums[j]，才能将 \textit{nums}[i]nums[i] 放在 \textit{nums}[j]nums[j] 后面以形成更长的上升子序列。

// 最后，整个数组的最长上升子序列即所有 dp[i]dp[i] 中的最大值。

// \text{LIS}_{\textit{length}}= \text{max}(dp[i]), \text{其中} \, 0\leq i < n
// LIS 
// length
// ​	
//  =max(dp[i]),其中0≤i<n

// 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

// 每行的元素从左到右升序排列。
// 每列的元素从上到下升序排列。
// 示例:

// 现有矩阵 matrix 如下：

// [
//   [1,   4,  7, 11, 15],
//   [2,   5,  8, 12, 19],
//   [3,   6,  9, 16, 22],
//   [10, 13, 14, 17, 24],
//   [18, 21, 23, 26, 30]
// ]
// 给定 target = 5，返回 true。
// 给定 target = 20，返回 false。

// var searchMatrix = function(matrix, target) {
    
// };
// 给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

//  

// 示例:

// 输入: [1,2,3,4]
      // [1,1,2,6]
      // [24,12,4,1]
// 输出: [24,12,8,6]

// 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

// 例如，

// [2,3,4] 的中位数是 3 3/2 1

// [2,3] 的中位数是 (2 + 3) / 2 = 2.5  

// 设计一个支持以下两种操作的数据结构：

// void addNum(int num) - 从数据流中添加一个整数到数据结构中。
// double findMedian() - 返回目前所有元素的中位数。
// 示例：

// addNum(1)
// addNum(2)
// findMedian() -> 1.5
// addNum(3) 
// findMedian() -> 2
// 进阶:

// 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
// 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？



/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

// var obj = new MedianFinder()
// obj.addNum(1)
// obj.addNum(2)

// console.log('obj.findMedian(): ', obj.findMedian());
// obj.addNum(3)
// console.log('obj.findMedian(): ', obj.findMedian());

// 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
// 请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

//  

// 前 K 个高频元素
// 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

//  

// 示例 1:

// 输入: nums = [1,1,1,2,2,3], k = 2
// 输出: [1,2]
// 示例 2:

// 输入: nums = [1], k = 1
// 输出: [1]
//  

// 提示：

// 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
// 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
// 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
// 你可以按任意顺序返回答案。

// 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

// 返回滑动窗口中的最大值。

//  

// 进阶：

// 你能在线性时间复杂度内解决此题吗？

// 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
// 输出: [3,3,5,5,6,7] 
// 解释: 

//   滑动窗口的位置                最大值
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7



 



// 给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

// 数学表达式如下:

// 如果存在这样的 i, j, k,  且满足 0 ≤ i < j < k ≤ n-1，
// 使得 arr[i] < arr[j] < arr[k] ，返回 true ; 否则返回 false 。
// 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。

// 示例 1:

// 输入: [1,2,3,4,5]
// 输出: true
// 示例 2:

// 输入: [5,4,3,2,1]
// 输出: false

async function post(){
  try{
    return {
      data:{
        response:{
          name:"fzhange"
        },
        status:0,
      }
    }
  }catch(error){
    return {}
  }
}
function check(data){
  // let res = data.data
  // return res
  throw new Error('>>>>>>>>>>>>error');
}

async function invoke(){
  try{
    let data = await post().then(check);
    console.log('data:>>> ', data);
  }catch(error){
    console.error('invoke__error: ', error);
  }
}

async function fun(){
  await invoke();
}
fun()


  </script>
  </body>
</html>
